"""Naive Bayes algorithm for adult dataSet."""
from input_bayes import Input
from input_bayes import ConvertData

def Bayes(data,dict,total_num):
  """Description.
  Args:
  data represents the data which has been converted by the method convertData
  dict is the ground set data dict generated from the adult.data file
  Returns:
  1 or 0 1 represents > 50k, 0 represents <= 50k
  """

  # Use Bayes classification method to predict the data label.
  # Suppose we denote the label by c variable and the different attributes by a0,a1,...,a12 variables.
  # The calculation procedure include several steps:
  # 1. Calculate the probabilities p(y=0) and p(y=1)
  # 2. Caluate the probabilities p(a0,a1,...,a12|y=0) and p(a0,a1,...,a12|y=1) by using the equations:
  # p(a0,a1,...,a12|y=0) = p(a0|y=0)*p(a1|y=0)*...*p(a12|y=0)
  # p(a0,a1,...,a12|y=1) = p(a0|y=1)*p(a1|y=1)*...*p(a12|y=1)
  # 3. Compare the values of p0=p(y=0)*p(a0,a1,...,a12|y=0) and p1=p(y=1)*p(a0,a1,...,a12|y=1)
  # If p0 >= p1, the label is 0. Else, the label is 1.

  label0_num = total_num[0]
  label1_num = total_num[1]

  #Step1. Calculate p(y=0) and p(y=1)
  p_label0 = float(label0_num) / (label0_num + label1_num) # the probability of label being 0
  p_label1 = float(label1_num) / (label0_num + label1_num) # the probability of label being 1

  #Step2. Calculate p(a0,a1,...,a12|y=0) and p(a0,a1,...,a12|y=1)
  p_con_mul_0 = 1.0 # the condition probability multiplication under the condition of label being 0
  p_con_mul_1 = 1.0 # the condition probability multiplication under the condition of label being 1
  dict_0 = dict[0] # Dict of the number of each attribute with the label 0, e.g.{'1':12,'2':2,...}
  dict_1 = dict[1] # Dict of the number of each attribute with the label 1
  for i in range(13):
    # Get the value of each attribute from the test sample.
    info = data[i]

    # Look up the number of this attribute in the dictionary.
    # Calculate the p(ai|y=0),i=0,1,...,12.
    if(info in dict_0[i]):
      info_num = int(dict_0[i][info])
      p_con_mul_0 *= (float(info_num) / label0_num)
    else:
      # If the dictionary doesn't contain this attribute value number, just set it to zero.
      p_con_mul_0 *= 0
    if(info in dict_1[i]):
      info_num = int(dict_1[i][info])
      p_con_mul_1 *= (float(info_num) / label1_num)
    else:
      p_con_mul_1 *= 0

  #Step3. Compare the values of p0=p(y=0)*p(a0,a1,...,a12|y=0) and p1=p(y=1)*p(a0,a1,...,a12|y=1)
  result0 = p_label0 * p_con_mul_0
  result1 = p_label1 * p_con_mul_1
  return 0 if result0 > result1 else 1

def Evaluate(test_url,report_url):
  """ Generate evaluation report file.
  Args:
    test_url represents the test dataset file path
    report_url represents the automatically generated file path
  Returns:
    This method returns nothing.
  """
  # Get the attributes dict and the total number array of the '>50K' and '<=50K' labels.
  dict, total_num = Input()

  # Count the correct, error and the unclasssified numbers of the test dataset.
  correct_num = error_num = unclassified_num=0

  # Open both the test dataset file and the report file.
  with open(test_url,'r') as ef:
    with open(report_url,'w') as rf:

      # Firstly, write some basic descriptions in the report file.
      rf.write('The report is generated by the program automatically!\n')
      rf.write('At the end of each record line, the classification result is given.\n')
      rf.write('If the record is classified successfully, it will be remarked as Correct.')
      rf.write('Otherwise, it will be remarked as Error.\n')
      rf.write('Besides, any record with the \'?\' symbol is not classified.So it will be remarked as Unclassified.\n')
      rf.write('Classification details:\n')
      ef.readline() # skip the first line since it contains no record.
      lines = ef.readlines() # read lines from the test dataset file.
      lines = lines[:-1] # skip the last since it just contains a single symbol '\n'
      index = 0

      # The main procedure:
      # 1. Get a line from the file lines and convert it into an attributes info array.
      # 2. Use Bayes method to get the prediction label of the sample.
      # 3. Write the each record and its prediction result into the report file.
      # 4. Count the correct, error and unclassfied numbers and write it into the report file.
      for line in lines:
        # Step1.Convert the line into an attributes info array.
        line = line[:-1] # remove the symbol '\n' in each line.
        infos = ConvertData(line)
        class_result = ''
        index += 1

        # Step2. Use Bayes method to get the prediction label of the sample.
        if infos == None:
          class_result = 'Unclassified'
          unclassified_num += 1
        else:
          pred_label = Bayes(infos,dict,total_num)
          if(pred_label != infos[13]):# the 13st attribute of the array infos represents the label.
            class_result = 'Error'
            error_num += 1
          else:
            class_result = 'Correct'
            correct_num += 1

        #Step3. Write the each record and its prediction result into the report file.
        rf.write(str(index) + ' : ' + line + ' ' + class_result+'\n')

  # 4. Count the correct, error and unclassfied numbers and write it in the report file.
  with open(report_url,'r') as rf:
    lines = rf.readlines()
  with open(report_url,'w+') as rf:
    append_lines = []
    append_lines.append('Classification conclusion:\n')
    append_lines.append('The test dataset size is ' + str(index) +'.')
    append_lines.append('Among all the records, there are '+str(correct_num)+ ' records are classified successfully, ')
    append_lines.append(str(error_num)+ ' records are misclassfied, ')
    append_lines.append(str(unclassified_num)+ ' records are unclassfied.\n')
    correct_percent = correct_num * 100.0 / (correct_num + error_num)
    append_lines.append('The classification accuracy is '+str(round(correct_percent,2))+ ' %.\n')
    lines = lines[:4] + append_lines + lines[4:]
    for line in lines:
      rf.write(line)

